####################################################################
# Part 4: SIR Algorithm to Approximately Sample from the Posterior #
####################################################################
# May 13 2024
# NOTE: HAS BEEN MODIFIED BY ANNA, BUT NOT APPROVED BY MIKE EVANS YET.

# Npostsamp = size of sample generated by the SIR algorithm
Npostsamp = 10

# This function generates an approximate iid sample of Npostsamp from the posterior using the SIR algorithm

SIR_algorithm = function(Npostsamp, cum_weights, p, mu_xi, xi, Sigma){
  #' Using the SIR algorithm from Rubin, values of i in {1, 2, ..., Npostimp}  
  #' and corresponding values of mu, xi and Sigma.   
  #' @param Npostsamp the size of the sample that will be generated.
  #' @param cum_weights the vector containing the cumulative weights.
  #' @param mu the mu matrix.
  #' @param xi the list containing xi's.
  U = runif(Npostsamp)
  i = findInterval(U, cum_weights)+1
  sample_mu_xi = mu_xi[i, ]
  sample_xi = xi[,,i]
  sample_Sigma = Sigma[i]
  newlist = list("sample_mu_xi" = sample_mu_xi, "sample_xi" = sample_xi, "sample_Sigma" = sample_Sigma)
  return(newlist)
}

post_SIR_sample = SIR_algorithm(Npostsamp, cum_weights = imp_cdf, 
                                p = p, mu = imp_mu, xi = imp_xi, Sigma = imp_Sigma)


mu_postsamp = post_SIR_sample$sample_mu_xi
xi_postsamp = post_SIR_sample$sample_xi
Sigma_postsamp = post_SIR_sample$sample_Sigma

Sigma_postsamp[[1]][indices[order(indices[,1]),]]

SIR_sample_reformat = function(Npostsamp, p, mu_matrix, xi_matrices, Sigma_matrices){
  #' Reformats the data for the user to download.
  #' @param Npostimp represents the Monte Carlo sample size.
  #' @param p represents the number of dimensions.
  
  mu_title = paste("Mu_", 1:p, sep = "")
  weights_title = "Weights"
  
  xi_title = character(p*(p+1)/2)  # Preallocate memory for the vector
  Sigma_title = character(p*(p+1)/2)
  k = 1
  for(i in 1:p){
    for(j in i:p){
      xi_title[k] = paste("Xi_", i, j, sep = "")
      Sigma_title[k] = paste("Sigma_", i, j, sep = "")
      k = k + 1
    }
  }
  xi_matrix = matrix(NA, nrow = Npostsamp, ncol = length(xi_title))
  Sigma_matrix = matrix(NA, nrow = Npostsamp, ncol = length(Sigma_title))
  
  # indices should be the same every time
  indices = which(upper.tri(xi_matrices[,,1], diag=TRUE), arr.ind=TRUE)
  for(i in 1:Npostsamp){ 
    new_row = xi_matrices[,,i][indices[order(indices[,1]),]]
    xi_matrix[i,] = as.vector(new_row)
    
    new_row = Sigma_matrices[[i]][indices[order(indices[,1]),]]
    Sigma_matrix[i,] = as.vector(new_row)
  }
  
  mu_data = as.data.frame(mu_matrix)
  xi_matrix = as.data.frame(xi_matrix)
  Sigma_matrix = as.data.frame(Sigma_matrix)
  
  names(mu_data) = mu_title
  names(xi_matrix) = xi_title
  names(Sigma_matrix) = Sigma_title
  
  result = cbind(mu_data, xi_matrix, Sigma_matrix)
  rownames(result) = 1:Npostsamp
  
  return(result)
}

SIR_sample_reformat(Npostsamp = Npostsamp, 
                    p = p, 
                    mu_matrix = mu_postsamp, 
                    xi_matrices = xi_postsamp, 
                    Sigma_matrices = Sigma_postsamp)







